
-----------------------------------
-- multivariate quasi polynomials



ZZ^5

M = image matrix {{0,5}, {2,0}}
rank M
Q = ZZ^2 / M
#Q


X.X
yy.
yy.
yy.
yy.
0yX


Q' = coker matrix {{1,0},{0,1}}

#Q'

peek Q'

Q'' = coker matrix {{1000000,0}, {0,1000000}}


M
Q
-- ZZ^2 --> Q
m = map(Q, ZZ^2, gens Q)
MQ = image m

peek MQ


M' = image transpose matrix {{15,4}, {5,2}}
mingens M'
mingens M

M == M'
gens M
gens M'

M''' = image matrix {{1,0,0,0}, {0,1,0,0}}
mingens M'''



--------------
R = ambient M

rank R == rank M -- maximal rank
mingens M -- canonical minimal generating set for M

-*
n := dim of ambeint space = rank M
for each generator r in mingens M consider the half-open intervals [0, r)

make the parallopiped generated by [0, r)
gives a half-open polytope with 2^n vertices --> set of coset representatives

*-


MultivariateQuasiPolynomial = new Type of HashTable

multivariateQuasiPolynomial = method()
multivariateQuasiPolynomial(Module, List, List) := (lattice, cosetReps, polys) -> (
		assert(rank lattice == rank ambient lattice);
		n := rank lattice;
		-- check that the coset representatives are really all the coset reps
		assert(#cosetReps == abs det mingens lattice); -- the number of coset reps is correct
		assert(#cosetReps == #polys);
		-- check that the cosetReps lie in distinct cosets of the lattice
		G := mingens lattice;
		assert(#(set for g in cosetReps list g % G) == #cosetReps);

		-- reduce the coset representatives modulo G
		cosetReps = for c in cosetReps list (c % G);
		-- Make a hashtable of polynomials for each coset representative
		H := hashTable for i from 0 to #cosetReps -1 list cosetReps_i => polys_i;
		-- sort the coset representatives
		C := sort(fold(cosetReps, (x, y) -> x | y)); -- sorted coset reps
		C = for i from 0 to #cosetReps - 1 list C_{i};

		-- and sort the list of polys in the same way
		sortedPolys := for c in C list H#(c % G); -- sorted polys

		-- check that the polys belong to the same ring with n variables
		assert(numgens ring matrix {polys} == n);

		-- for each cosetRep store the corresponding polynomial
		cosetPolys := hashTable for i from 0 to #cosetReps -1 list C_i => polys_i;
		new MultivariateQuasiPolynomial from {
				cache => new CacheTable,
				Lattice => lattice, -- full-rank ZZ-Module
			  	PolynomialFibers => cosetPolys
				}
		)

-- assume that v is a column vector
MultivariateQuasiPolynomial Matrix := (F, v) -> (
		-- TODO: check that v lives in the right space
		F#PolynomialFibers#(v % (mingens F#Lattice)) toSequence first entries transpose v
		)







M = image transpose matrix {{2,0}, {0,2}}

cosets = {
		matrix {{0},{0}},
		matrix {{0},{3}},
		matrix {{17},{4}},
		matrix {{15},{15}}
		}

R = QQ[x_1, x_2]
polys = {1_R, 0_R, 0_R, 0_R}
polys2 = {1_R, R_0^2, R_1^2, R_0*R_1 + 1}

F = multivariateQuasiPolynomial(M, cosets, polys)
F2 = multivariateQuasiPolynomial(M, cosets, polys2)

cosets' = {
		matrix {{0},{0}},
		matrix {{0},{1}},
		matrix {{1},{0}},
		matrix {{1},{1}}
		}

F' = multivariateQuasiPolynomial(M, cosets', polys)
F === F'




cosets'' = {
		matrix {{0},{0}},
		matrix {{0},{1}},
		matrix {{16},{17}},
		matrix {{15},{15}}
		}

multivariateQuasiPolynomial(M, cosets'', polys)


R' = QQ[x_1,x_2,x_3]
polys' = {1_R', 0_R', 0_R', 0_R'}

multivariateQuasiPolynomial(M, cosets, polys')


F matrix {{3},{10}}






-- Constructing a multivariate quasi polynomial from a polytope and polynomial

-- TODO: Check the setup:
-- 1. P is a polytope
-- 2. w is a QuasiPolynomial acting on the lattice of the ambient space of P

-- First we follow the setup where e = 0 in Theorem 1.1 of https://arxiv.org/pdf/2402.11328


ehrhartQuasiPolynomial = method()
ehrhartQuasiPolynomial(Polyhedron, MultivariateQuasiPolynomial) := (P, w) -> (
	-- R := ring w; -- TODO: define this ...
	-- ambientDimension := rank target vertices P;
	-- assert(numgens R == ambientDimension); -- check that the polynomial lie in a ring with the right number of variables



	-- output a quasi polynomial of P with respect to the weight f
	-- ...
)

ehrhartSeries = method()
ehrhartSeries(Polyhedron, RingElement) := (P, f) -> (
	R := ring f;
	ambientDimension := rank target vertices P;
	assert(numgens R == ambientDimension); -- check that the polynomial lie in a ring with the right number of variables



	-- output a quasi polynomial of P with respect to the weight f
	-- ...
)




P = convexHull matrix {{0,0,1,3}, {0,1,0,3}}
ambientDimension = rank target vertices P


-----------------------------------------


-- Fix polytope (rational / lattice) P
-- Fix a (quasi / normal)-polynomial w

-- Compute: EhrhartQP(P, w)

-- Assume we know the regions of polynomiality of w

-- Problem 1.
-- Can we check if w if of the form of Theorem 1.1 by looking at its evaluation at a basis and cooking
-- up the matrix C, vectors d_i, e that would have to exist in this case?
-- Is there an algorithm to check this? (Literature? - couldn't find anything after a quick look)
-- [Sounds like a potentially very difficult problem, note that given w we need to determine C, d_i, e,
--  in particular, we need to determine the dimension of Q(x_1 .. x_n) (m), which could be very large]


-- If w is of the form of Theorem 1.1 with (e = 0) then we have big shortcut: compute EhrhartQP(P*)
-- If w is of the form of Theorem 1.1 with (e != 0) then we can use it to compute the number of lattice points


-- Problem 2.
-- As in Theorem 1.1: given C, d_i, e, what is the multivariate Quasi polynomial w(x_1 .. x_n)?
-- In particular, is there an algorithm to compute its regions of polynomiality?
-- Can we bound the number of polynomial regions of w? And the degree of the polynomial on those regions?

-- Potentially we can start by looking at small m i.e., the polytopes Q are low dimensional, or just points
--
-- How do the regions of polynomiality relate to the denomiator of Q(f_i) where f_i are the standard basis vectors?
-- Is it the case that all of these polytopes Q(f_i) have the same denominator? (Maybe no?)
--


--
-- If we can do Problem 2. even for some small families of examples, then one way to use Theorem 1.1
-- is to precompute some families of examples where we obtain w from C, d_i, e - like a database -
-- as a quick check on the input



-- TODO:
-- If w is a polynomial (not quasi-polynomial) then we can have a default option to use
-- Normaliz by passing in the polynomial into the input file: see section 7.9.1 in the Normaliz documentation
--

-- Problem 3.
-- How can we use this (the polynomial weight case) to compute the general multi-variate
-- quasipolynomial weight case? (try doing it region by region)
--
