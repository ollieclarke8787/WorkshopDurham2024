
-----------------------------------
-- multivariate quasi polynomials



ZZ^5

M = image matrix {{0,5}, {2,0}}
rank M
Q = ZZ^2 / M
#Q


X.X
yy.
yy.
yy.
yy.
0yX


Q' = coker matrix {{1,0},{0,1}}

#Q'

peek Q'

Q'' = coker matrix {{1000000,0}, {0,1000000}}


M
Q
-- ZZ^2 --> Q
m = map(Q, ZZ^2, gens Q)
MQ = image m

peek MQ


M' = image transpose matrix {{15,4}, {5,2}}
mingens M'
mingens M

M == M'
gens M
gens M'

M''' = image matrix {{1,0,0,0}, {0,1,0,0}}
mingens M'''



--------------
R = ambient M

rank R == rank M -- maximal rank
mingens M -- canonical minimal generating set for M

-*
n := dim of ambeint space = rank M
for each generator r in mingens M consider the half-open intervals [0, r)

make the parallopiped generated by [0, r)
gives a half-open polytope with 2^n vertices --> set of coset representatives

*-


MultivariateQuasiPolynomial = new Type of HashTable

multivariateQuasiPolynomial = method()
multivariateQuasiPolynomial(Module, List, List) := (lattice, cosetReps, polys) -> (
		assert(rank lattice == rank ambient lattice);
		n := rank lattice;
		-- check that the coset representatives are really all the coset reps
		assert(#cosetReps == abs det mingens lattice); -- the number of coset reps is correct
		assert(#cosetReps == #polys);
		-- check that the cosetReps lie in distinct cosets of the lattice
		G := mingens lattice;
		assert(#(set for g in cosetReps list g % G) == #cosetReps);

		-- reduce the coset representatives modulo G
		cosetReps = for c in cosetReps list (c % G);
		-- Make a hashtable of polynomials for each coset representative
		H := hashTable for i from 0 to #cosetReps -1 list cosetReps_i => polys_i;
		-- sort the coset representatives
		C := sort(fold(cosetReps, (x, y) -> x | y)); -- sorted coset reps
		C = for i from 0 to #cosetReps - 1 list C_{i};

		-- and sort the list of polys in the same way
		sortedPolys := for c in C list H#(c % G); -- sorted polys

		-- check that the polys belong to the same ring with n variables
		assert(numgens ring matrix {polys} == n);

		-- for each cosetRep store the corresponding polynomial
		cosetPolys := hashTable for i from 0 to #cosetReps -1 list C_i => polys_i;
		new MultivariateQuasiPolynomial from {
				cache => new CacheTable,
				Lattice => lattice, -- full-rank ZZ-Module
			  	PolynomialFibers => cosetPolys
				}
		)

-- assume that v is a column vector
MultivariateQuasiPolynomial Matrix := (F, v) -> (
		-- TODO: check that v lives in the right space
		F#PolynomialFibers#(v % (mingens F#Lattice)) toSequence first entries transpose v
		)







M = image transpose matrix {{2,0}, {0,2}}

cosets = {
		matrix {{0},{0}},
		matrix {{0},{3}},
		matrix {{17},{4}},
		matrix {{15},{15}}
		}

R = QQ[x_1, x_2]
polys = {1_R, 0_R, 0_R, 0_R}
polys2 = {1_R, R_0^2, R_1^2, R_0*R_1 + 1}

F = multivariateQuasiPolynomial(M, cosets, polys)
F2 = multivariateQuasiPolynomial(M, cosets, polys2)

cosets' = {
		matrix {{0},{0}},
		matrix {{0},{1}},
		matrix {{1},{0}},
		matrix {{1},{1}}
		}

F' = multivariateQuasiPolynomial(M, cosets', polys)
F === F'




cosets'' = {
		matrix {{0},{0}},
		matrix {{0},{1}},
		matrix {{16},{17}},
		matrix {{15},{15}}
		}

multivariateQuasiPolynomial(M, cosets'', polys)


R' = QQ[x_1,x_2,x_3]
polys' = {1_R', 0_R', 0_R', 0_R'}

multivariateQuasiPolynomial(M, cosets, polys')


F matrix {{3},{10}}






-- Constructing a multivariate quasi polynomial from a polytope and polynomial

-- TODO: Check the setup:
-- 1. P is a polytope
-- 2. w is a QuasiPolynomial acting on the lattice of the ambient space of P

-- First we follow the setup where e = 0 in Theorem 1.1 of https://arxiv.org/pdf/2402.11328


ehrhartQuasiPolynomial = method()
ehrhartQuasiPolynomial(Polyhedron, MultivariateQuasiPolynomial) := (P, w) -> (
	-- R := ring w; -- TODO: define this ...
	-- ambientDimension := rank target vertices P; 
	-- assert(numgens R == ambientDimension); -- check that the polynomial lie in a ring with the right number of variables



	-- output a quasi polynomial of P with respect to the weight f
	-- ...
)

ehrhartSeries = method()
ehrhartSeries(Polyhedron, RingElement) := (P, f) -> (
	R := ring f;
	ambientDimension := rank target vertices P; 
	assert(numgens R == ambientDimension); -- check that the polynomial lie in a ring with the right number of variables



	-- output a quasi polynomial of P with respect to the weight f
	-- ...
)




P = convexHull matrix {{0,0,1,3}, {0,1,0,3}}
ambientDimension = rank target vertices P 
