-- equivariant Ehrhart theory is the Ehrhart theory of symmetric polytopes
--

needsPackage "RationalPolytopes"
needsPackage "BettiCharacters"

-- permutation matrix from permutation
-- expected permutation on indices 0 .. n-1
permutationMatrix = method()
permutationMatrix List := S -> (
    n := #S;
    matrix for i from 0 to n-1 list for j from 0 to n-1 list if S_i == j then 1 else 0
    )

symmetricGroup = method()
symmetricGroup ZZ := n -> (
    if n < 1 then error("invalid matrix size");
    for S in permutations(n) list permutationMatrix S
    )


-- given a polytope P and a matrix M or list of matrices L
-- check that P is invariant under M or under each matrix in L
isSymmetric = method()
isSymmetric(Polyhedron, Matrix) := (P, M) -> (
    V := sort vertices P; -- vertices of P are probably already sorted
    if numColumns M != numRows M then error("matrix must be square");
    if numColumns M != numRows V then error("matrix incompatible with polytope");
    MV := sort M * V;
    if ring MV =!= ring V then error("rings of matrices are different");
    MV == V
    )

isSymmetric(Polyhedron, List) := (P, L) -> (
    result := true;
    for M in L do if not isSymmetric(P, M) then (result = false; break);
    result
    )

-- group generated by a list of matrices
-- the user should guarantee that the group they generate is finite
group = method(
    Options => {
	Verbose => false
	}
    )
group List := opts -> L -> (
    local g;
    local h;
    local gh;
    -- construct a Cayley table of the group
    countMults := 0;
    groupElements := new MutableHashTable from for M in L list M => true;
    multsToCheck := new MutableList from flatten for i from 0 to #L-1 list for j from 0 to i list (L_i, L_j);
    while #multsToCheck > 0 do (
        -- pop one mult
	(g, h) = remove(multsToCheck, -1);
	gh = g * h;
	countMults = countMults +1;
	if not groupElements#?gh then (
	    groupElements#gh = true;
	    for f in keys groupElements do multsToCheck##multsToCheck = (gh, f);
	    -- note that gh*gh is not necessary to add because we will get to it eventually by gh*g*h
	    if opts.Verbose then (
		print("found element: " | net gh | " (total elements: " | toString(#groupElements) | ")");
		);
	    );
	if opts.Verbose then (
	    print("-- remains to check " | toString (#multsToCheck) | " multiplicaions");
	    );
	);
    if opts.Verbose then (
	print("-- completed in " | toString countMults | " multiplications");
	);
    keys groupElements
    )


-- conjugacy classes takes a list of matrices, which is a group,
-- and returns a list of list of elements belonging to conugacy classes

conjugacyClasses = method(
    Options => {
	Verbose => false,
	ListRepsOnly => false
	}
    )
conjugacyClasses List := opts -> G -> (
    numConjugations := 0;
    isClassified := new MutableHashTable from for g in G list g => false;
    result := for g in G list (
	if isClassified#g then continue else (
	    if opts.Verbose then (
		print("new class: " | net g);
		print("");
		);
	    isClassified#g = true;
	    conjClass := new MutableHashTable from {g => true};
	    for h in G do (
		hgh := h * g * h^(-1);
		numConjugations = numConjugations + 1;
		if not conjClass#?hgh then (isClassified#hgh = true; conjClass#hgh = true);
		);
	    if opts.ListRepsOnly then g else keys conjClass
	    )
	);
    if opts.Verbose then (
	print("-- completed in " | toString numConjugations | " conjugations");
	);
    result
    )


-- takes a partition L of n and returns a permutation
-- with cycle type L
partitionToPermutation = method()
partitionToPermutation List := L -> (
    cycleStart := 0;
    flatten for cycleLength in L list (
	cycleStart = cycleStart + cycleLength;
	for i from cycleStart - cycleLength to cycleStart -1 list (
	    if i == cycleStart -1 then cycleStart - cycleLength else i + 1
	    )
	)
    )

-- get conjugacy class reps for Sn
-- living as n x n permutation matrices
snConjugacyClassReps = method()
snConjugacyClassReps ZZ := n -> (
    S := toList \ partitions n;
    for s in S list permutationMatrix partitionToPermutation s
    )


-- return the subset of points of P that are fixed by g
fixedPolytope = method()
fixedPolytope(Polyhedron, Matrix) := (P, g) -> (
    n := numRows vertices P;
    if numRows g != numColumns g or numRows g != n then error("matrix size mismatch");
    gFixedSpace := coneFromHData(map(ZZ^0, ZZ^n, 0), g - id_(ZZ^n));
    intersection(P, gFixedSpace)
    )

-- hypersimplex
hypersimplex = method()
hypersimplex(ZZ, ZZ) := (n, k) -> (
    convexHull transpose matrix for s in subsets(n, k) list (
	for i from 0 to n-1 list if member(i, s) then 1 else 0
	)
    )

permutohedron = method()
permutohedron ZZ := n -> (
    convexHull transpose matrix permutations n
    )



-- representation ring of Sn over QQ
-- order of the rows and cols of character table
-- is given by 'partitions n'
repRing = method(Options => {ReturnTable => false})
repRing ZZ := opts -> n -> (
    a := getSymbol "a";
    x := getSymbol "x";
    R := QQ[a_1 .. a_n];
    T := symmetricGroupTable R;
    M := sub(T.table, QQ);
    N := inverse transpose M;
    m := numRows M;
    S := QQ[x_1 .. x_m];
    -*
    X := matrix {gens S};
    I := ideal flatten for i from 0 to m-1 list for j from 0 to i list (
	-- product of rows i and j in M
	S_i * S_j - (X * N * transpose matrix {for k from 0 to m-1 list M_(i, k) * M_(j, k)})_(0,0)
	);
    if opts.ReturnTable then (S/I, T) else S/I
    *-
    if opts.ReturnTable then (S, M) else S
    )


-- EES of a polytope invariant under Sn
equivariantEhrhartSeries = method(
    Options => {
	ReturnTable => true,
	ReturnPartitionList => true,
	ReturnHStarList => true
	})
equivariantEhrhartSeries Polyhedron := opts -> P -> (
		n := numRows vertices P;
		-- check P invariant under Sn
		g1 := permutationMatrix(toList(1 .. n-1) | {0}); -- n cycle
		g2 := permutationMatrix({1,0} | toList(2 .. n-1)); -- transposition
		if not (isSymmetric(P, g1) and isSymmetric(P, g2)) then error("polytope is not Sn invariant");
		conjClassRepMats := snConjugacyClassReps n;
		fixedPolytopeList := (g -> fixedPolytope(P, g)) \ conjClassRepMats;
		(R, T) := repRing(n, ReturnTable => true);
		m := numgens R; -- equals number of conj classes
		Rt := R[getSymbol "t"];
		t := Rt_0;
		hStarList := (Pg -> hStar(Pg, Rt, ReturnDenominator => true)) \ fixedPolytopeList;
		ehrhartHStarList := for i from 0 to m-1 list (
				g := sub(conjClassRepMats_i, Rt);
				detRep := det(id_(Rt^n) - t*g);
				(hStarNum, hStarDenom) := hStarList_i;
				if not zero((hStarNum * detRep) % hStarDenom) then (
						print "bad symmetry:";
						print g;
						error("equivariant hStar not polynomial");
						);
				(hStarNum * detRep) // hStarDenom
				); -- list of Ehrhart H* polynomials note that denominator is det(I - tg)
		H := (matrix {ehrhartHStarList} * (inverse T) * transpose matrix {gens R})_(0,0);
		result := {H};
		if opts.ReturnTable then result = result | {T};
		if opts.ReturnPartitionList then result = result | {toList \ partitions n};
		if opts.ReturnHStarList then result = result | {ehrhartHStarList};
		result
		)


-- obit polytope under Sn
-- expects a single column matrix: a point in QQ^n
orbitPolytope = method()
orbitPolytope Matrix := p -> (
    n := numRows p;
    if numColumns p != 1 then error("expected matrix with 1 column");
    V := map(QQ^n, QQ^0, 0);
    for g in symmetricGroup n do (
	V = V | g*p;
	);
    convexHull V
    )











---------------------------------------
-- For the hypersimplex, Alan asks if there is a bijection between the
-- DOSPs and a (equivariant) basis for the algebra R/J where
--
-- R = CC[x_s : s \in \binom{[n]}{k}] \subseteq CC[x_1 .. x_n]
--   where x_s is the product \prod x_i taken over i \in s
--
-- J = ideal(x_i * e_{k-1}(x_1 .. x_{i-1}, x_{i+1} .. x_n) : i \in [n])
--   where e_{k-1} is the (k-1)-th symmetric polynomial

needsPackage "SubalgebraBases"
needsPackage "FourTiTwo"


hypersimplexIdeal = method()
hypersimplexIdeal(ZZ, ZZ) := (n, k) -> (
		S := subsets(1 .. n, k);
		x := symbol x;
		R := QQ[for s in S list x_(toSequence s), MonomialOrder => GLex];
		lookupGen := hashTable for i from 0 to #S-1 list S_i => (gens R)_i;
		J := ideal for i from 1 to n list sum (
				S' := subsets(1 .. i-1 | i+1 .. n, k-1);
				apply(S', s -> lookupGen#(sort({i} | s)))
				);
		-- 4ti2 to compute the toric part of the ideal
		A := transpose matrix for s in S list for i from 1 to n list if member(i, s) then 1 else 0;
		K := toricGroebner(A, R);
		-*
		y := symbol y;
		C := QQ[y_1 .. y_n];
		m := map(C, R, for s in S list product for i in s list y_i);
		K := ker m; -- would be much faster to do this with 4ti2
		*-
		J + K
		)



-- Ollie's conjecture for the basis of the EhrhartRing / linear hilbertSeries
-- given by DOSP indexed elements: x[A]^w + x[B]^w
-- where D = {A, B} is a DOSP given as a partition of [n]

testConj = method(
		Options => {
				Verbose => false,
				ReturnNewBasis => false,
				ReturnDosps => false
				}
		)
testConj ZZ := opts -> n -> (
		if opts.Verbose then print("-- initial setup");
		assert(n >= 4); -- assume n >= 4
		I := hypersimplexIdeal(n, 2);
		R := ring I;
		Q := R/I;

		B := basis Q;
		M := image B;

		subsetList := subsets(1 .. n, 2);
		lookupQGen := hashTable for i from 0 to #subsetList - 1 list subsetList_i => Q_i;

		if opts.Verbose then print("-- computing dosps");
		dosps := flatten for i from 0 to n // 2 list (
				-- partitions {A, B} where |A| = i
				if i == 1 then continue
				else if 2*i < n then for s in subsets(1 .. n, i) list (
						{s, select(toList(1 .. n), i -> not member(i, s))}
						)
				else (
						-- 2*i == n
						for s in subsets(2 .. n, i-1) list (
								{{1} | s, select(toList(2 .. n), i -> not member(i, s))}
								)
						)
				);

		if opts.Verbose then print("-- constructing proposed basis");
		B' := for D in dosps list (
				A := D_0;
				B := D_1;

				xA := (sum for s in subsets(A, 2) list lookupQGen#s)_Q;
				xB := (sum for s in subsets(B, 2) list lookupQGen#s)_Q;

				windingNumber := sum for i from 0 to #A - 1 list (
						if i == #A - 1 then (if A_0 == 1 and A_i == n then 0 else 1)
						else if A_(i+1) - A_i == 1 then 0
						else 1
						);

				xA^windingNumber + xB^windingNumber
				);

		if opts.Verbose then print("-- creating module");
		M' := image matrix {for b in B' list b_Q};

		if opts.Verbose then print("-- testing equality of modules");

		result := {(M == M')}; -- equality of modules

		if opts.ReturnNewBasis then result = result | {B'};
		if opts.ReturnDosps then result = result | {dosps};

		toSequence result
		)


-- get the winding number of a DOSP D = {A, B}
-- for k = 2
windingNumber = method()
windingNumber(List, ZZ) := (D, n) -> (
		A := D_0;
		sum for i from 0 to #A - 1 list (
				if i == #A - 1 then (if A_0 == 1 and A_i == n then 0 else 1)
				else if A_(i+1) - A_i == 1 then 0
				else 1
				)
		)



end

load "equivariantEhrhart.m2"

P = convexHull transpose matrix "1,1,0,0;1,0,1,0;1,0,0,1;0,1,1,0;0,1,0,1;0,0,1,1"
M2134 = matrix "0,1,0,0;1,0,0,0;0,0,1,0;0,0,0,1"
M2341 = matrix "0,1,0,0;0,0,1,0;0,0,0,1;1,0,0,0"
M3214 = matrix "0,0,1,0;0,1,0,0;1,0,0,0;0,0,0,1"

isSymmetric(P, M2134)
isSymmetric(P, M2341)
isSymmetric(P, {M2134, M2341})

L = {M2134, M2341, id_(ZZ^4)}
G = group(L, Verbose => true)

L' = {M2341, M3214}
G' = group(L', Verbose => true)

#G
#G'

netList conjugacyClasses(G, Verbose => true, ListRepsOnly => true)
netList conjugacyClasses(G', Verbose => true, ListRepsOnly => true)

M23451 = permutationMatrix {1,2,3,4,0}
M21345 = permutationMatrix {1,0,2,3,4}
S5 = elapsedTime group({M23451, M21345});

M234561 = permutationMatrix {1,2,3,4,5,0}
M213456 = permutationMatrix {1,0,2,3,4,5}
S6 = elapsedTime group({M234561, M213456}, Verbose => true);
-- took around 300 seconds (Verbose mode)

T6 = symmetricGroup(6);

D12 = group({
	permutationMatrix {1,2,3,4,5,0},
	permutationMatrix {0,5,4,3,2,1}},
    Verbose => true)

conjugacyClasses(T6, ListRepsOnly => true)


P = hypersimplex(6, 2)
S5 = symmetricGroup(5);
C = conjugacyClasses(S5, ListRepsOnly => true)

netList elapsedTime equivariantEhrhartSeries hypersimplex(6, 3)
equivariantEhrhartSeries permutohedron 3


P = orbitPolytope transpose matrix "0,0,0,1,2"
vertices P
netList equivariantEhrhartSeries P


P = orbitPolytope transpose matrix "0,1,3"
vertices P
netList equivariantEhrhartSeries P

--------------------
A = QQ[x]
B = frac A[t]
1/(B_0)
--------------------

restart
load "equivariantEhrhart.m2"


P = hypersimplex(6, 2)
S5 = symmetricGroup(5);
C = conjugacyClasses(S5, ListRepsOnly => true)

netList elapsedTime equivariantEhrhartSeries hypersimplex(6, 3);
elapsedTime equivariantEhrhartSeries hypersimplex(9, 2);

equivariantEhrhartSeries permutohedron 4



restart
load "equivariantEhrhart.m2"

P = convexHull transpose matrix {
		{1,1,0,0,1},
		{1,1,1,0,0},
		{0,1,1,1,0},
		{0,0,1,1,1},
		{1,0,0,1,1}
		}

netList elapsedTime equivariantEhrhartSeries P







---------------------------------------------------------------------------------
n = 4
k = 2


S = subsets(1 .. n, k)

transpose matrix for s in S list for i from 1 to n list if member(i, s) then 1 else 0
x = symbol x

R = QQ[for s in S list x_(toSequence s)]

lookupGen = hashTable for i from 0 to #S-1 list S_i => (gens R)_i

J = ideal for i from 1 to n list sum (
		S' = subsets(1 .. i-1 | i+1 .. n, k-1);
		apply(S', s -> lookupGen#(sort({i} | s)))
		)

C = QQ[y_1 .. y_n]
m = map(C, R, for s in S list product for i in s list y_i)
K = ker m

I = J + K
transpose gens gb I
dim I

Q = R/I

SQ = subring gens Q
gens sagbi SQ

hilbertSeries(Q, Order => 3)

F = res I

---------------------

load "equivariantEhrhart.m2"
I = hypersimplexIdeal(4, 2);
R = ring I
Q = R/I
hilbertSeries(I, Order => 10)

transpose basis Q
transpose presentation Q
transpose matrix {sort first entries basis Q}



(gens Q)_0 + (gens Q)_5 -- x_(1,2) + x_(3,4)
(gens Q)_2 + (gens Q)_3 -- x_(2,3) + x_(1,4)
(gens Q)_1^2 + (gens Q)_4^2 -- x_(2,4)^2 + x_(1,3)^2

--------------

I = hypersimplexIdeal(6, 2);
R = ring I
Q = R/I
hilbertSeries(I, Order => 10)

transpose basis Q
transpose presentation Q
transpose matrix {sort first entries basis Q}



(gens Q)_0 + (gens Q)_5 -- x_(1,2) + x_(3,4)
(gens Q)_2 + (gens Q)_3 -- x_(2,3) + x_(1,4)
(gens Q)_1^2 + (gens Q)_4^2 -- x_(2,4)^2 + x_(1,3)^2





use Q

b_1 = x_(1,2)
b_2 = x_(1,4)
b_1 + b_2

b_1^2
b_2^2

b_1^2 - b_2^2


----------------------
-- Code for testing Conjecture for C-basis of the algebra
--


-- Rough code used in creating the function "testConj"

n = 6
k = 2

I = hypersimplexIdeal(n, k);
R = ring I
Q = R/I
hilbertSeries(I, Order => 10)
B = basis Q
M = image B


subsetList = subsets(1 .. n, k)
lookupQGen = hashTable for i from 0 to #subsetList - 1 list subsetList_i => Q_i


dosps = flatten for i from 0 to n // 2 list (
		-- partitions {A, B} where |A| = i
		if 2*i < n then for s in subsets(1 .. n, i) list (
				{s, select(toList(1 .. n), i -> not member(i, s))}
				)
		else (
				-- 2*i == n
				for s in subsets(2 .. n, i-1) list (
						{{1} | s, select(toList(2 .. n), i -> not member(i, s))}
						)
				)
		)

A = {1,2,3}
B = {4,5,6}

xA = (sum for s in subsets(A, 2) list lookupQGen#s)_Q
xB = (sum for s in subsets(B, 2) list lookupQGen#s)_Q

windingNumber = sum for i from 0 to #A - 1 list (
		if i == #A - 1 then (if A_0 == 1 and A_i == n then 0 else 1)
		else if A_(i+1) - A_i == 1 then 0
		else 1
		)


xA^windingNumber + xB^windingNumber

------------------------------------


----------------------------------------
-- Tests for the k=2 Basis Conjecture --
----------------------------------------
restart
load "equivariantEhrhart.m2"

testConj(9)
testConj(10, Verbose => true)

-- conjecture seems to be true up and including to n = 10

n = 6
(result, B, dosps) = testConj(n, ReturnNewBasis => true, ReturnDosps => true);

-- basis elements:
netList B

-- Basis element | DOSP | winding number
netList for i from 0 to #B -1 list {B_i, dosps_i, windingNumber(dosps_i, n)}
