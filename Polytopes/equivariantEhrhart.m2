-- equivariant Ehrhart theory is the Ehrhart theory of symmetric polytopes
--

needsPackage "RationalPolytopes"
needsPackage "BettiCharacters"

-- permutation matrix from permutation
-- expected permutation on indices 0 .. n-1
permutationMatrix = method()
permutationMatrix List := S -> (
    n := #S;
    matrix for i from 0 to n-1 list for j from 0 to n-1 list if S_i == j then 1 else 0
    )

symmetricGroup = method()
symmetricGroup ZZ := n -> (
    if n < 1 then error("invalid matrix size");
    for S in permutations(n) list permutationMatrix S
    )


-- given a polytope P and a matrix M or list of matrices L
-- check that P is invariant under M or under each matrix in L
isSymmetric = method()
isSymmetric(Polyhedron, Matrix) := (P, M) -> (
    V := sort vertices P; -- vertices of P are probably already sorted
    if numColumns M != numRows M then error("matrix must be square");
    if numColumns M != numRows V then error("matrix incompatible with polytope");
    MV := sort M * V;
    if ring MV =!= ring V then error("rings of matrices are different");
    MV == V
    )

isSymmetric(Polyhedron, List) := (P, L) -> (
    result := true;
    for M in L do if not isSymmetric(P, M) then (result = false; break); 
    result
    )

-- group generated by a list of matrices
-- the user should guarantee that the group they generate is finite
group = method(
    Options => {
	Verbose => false
	}
    )
group List := opts -> L -> (
    local g;
    local h;
    local gh;
    -- construct a Cayley table of the group
    countMults := 0;
    groupElements := new MutableHashTable from for M in L list M => true;
    multsToCheck := new MutableList from flatten for i from 0 to #L-1 list for j from 0 to i list (L_i, L_j);
    while #multsToCheck > 0 do (
        -- pop one mult
	(g, h) = remove(multsToCheck, -1);
	gh = g * h;
	countMults = countMults +1;
	if not groupElements#?gh then (
	    groupElements#gh = true;
	    for f in keys groupElements do multsToCheck##multsToCheck = (gh, f);
	    -- note that gh*gh is not necessary to add because we will get to it eventually by gh*g*h
	    if opts.Verbose then (
		print("found element: " | net gh | " (total elements: " | toString(#groupElements) | ")");
		);
	    );
	if opts.Verbose then (
	    print("-- remains to check " | toString (#multsToCheck) | " multiplicaions");
	    );
	);
    if opts.Verbose then (
	print("-- completed in " | toString countMults | " multiplications");
	);
    keys groupElements
    )


-- conjugacy classes takes a list of matrices, which is a group,
-- and returns a list of list of elements belonging to conugacy classes

conjugacyClasses = method(
    Options => {
	Verbose => false,
	ListRepsOnly => false
	}
    )
conjugacyClasses List := opts -> G -> (
    numConjugations := 0;
    isClassified := new MutableHashTable from for g in G list g => false;
    result := for g in G list (
	if isClassified#g then continue else (
	    if opts.Verbose then (
		print("new class: " | net g);
		print("");
		);	  
	    isClassified#g = true;
	    conjClass := new MutableHashTable from {g => true};
	    for h in G do (
		hgh := h * g * h^(-1);
		numConjugations = numConjugations + 1;
		if not conjClass#?hgh then (isClassified#hgh = true; conjClass#hgh = true); 
		);
	    if opts.ListRepsOnly then g else keys conjClass
	    )
	);
    if opts.Verbose then (
	print("-- completed in " | toString numConjugations | " conjugations");
	);
    result 
    )


-- takes a partition L of n and returns a permutation
-- with cycle type L
partitionToPermutation = method()
partitionToPermutation List := L -> (
    cycleStart := 0;
    flatten for cycleLength in L list (
	cycleStart = cycleStart + cycleLength;
	for i from cycleStart - cycleLength to cycleStart -1 list (
	    if i == cycleStart -1 then cycleStart - cycleLength else i + 1
	    )
	)
    )

-- get conjugacy class reps for Sn
-- living as n x n permutation matrices
snConjugacyClassReps = method()
snConjugacyClassReps ZZ := n -> (
    S := toList \ partitions n;
    for s in S list permutationMatrix partitionToPermutation s
    )


-- return the subset of points of P that are fixed by g
fixedPolytope = method()
fixedPolytope(Polyhedron, Matrix) := (P, g) -> (
    n := numRows vertices P;
    if numRows g != numColumns g or numRows g != n then error("matrix size mismatch");
    gFixedSpace := coneFromHData(map(ZZ^0, ZZ^n, 0), g - id_(ZZ^n));
    intersection(P, gFixedSpace)
    )

-- hypersimplex
hypersimplex = method()
hypersimplex(ZZ, ZZ) := (n, k) -> (
    convexHull transpose matrix for s in subsets(n, k) list (
	for i from 0 to n-1 list if member(i, s) then 1 else 0
	)
    )

permutohedron = method()
permutohedron ZZ := n -> (
    convexHull transpose matrix permutations n
    )



-- representation ring of Sn over QQ
-- order of the rows and cols of character table
-- is given by 'partitions n'
repRing = method(Options => {ReturnTable => false})
repRing ZZ := opts -> n -> (
    a := getSymbol "a";
    x := getSymbol "x";
    R := QQ[a_1 .. a_n];
    T := symmetricGroupTable R;
    M := sub(T.table, QQ);
    N := inverse transpose M;
    m := numRows M;
    S := QQ[x_1 .. x_m];
    -*
    X := matrix {gens S};
    I := ideal flatten for i from 0 to m-1 list for j from 0 to i list (
	-- product of rows i and j in M
	S_i * S_j - (X * N * transpose matrix {for k from 0 to m-1 list M_(i, k) * M_(j, k)})_(0,0)
	);
    if opts.ReturnTable then (S/I, T) else S/I
    *-
    if opts.ReturnTable then (S, M) else S
    )


-- EES of a polytope invariant under Sn
equivariantEhrhartSeries = method(
    Options => {
	ReturnTable => true,
	ReturnPartitionList => true,
	ReturnHStarList => true
	})
equivariantEhrhartSeries Polyhedron := opts -> P -> (
    n := numRows vertices P;
    -- check P invariant under Sn
    g1 := permutationMatrix(toList(1 .. n-1) | {0}); -- n cycle
    g2 := permutationMatrix({1,0} | toList(2 .. n-1)); -- transposition
    if not (isSymmetric(P, g1) and isSymmetric(P, g2)) then error("polytope is not Sn invariant");
    conjClassRepMats := snConjugacyClassReps n;
    fixedPolytopeList := (g -> fixedPolytope(P, g)) \ conjClassRepMats;
    (R, T) := repRing(n, ReturnTable => true);
    m := numgens R; -- equals number of conj classes
    Rt := R[getSymbol "t"];
    t := Rt_0;
    hStarList := (Pg -> hStar(Pg, Rt, ReturnDenominator => true)) \ fixedPolytopeList;
    ehrhartHStarList := for i from 0 to m-1 list (
	g := sub(conjClassRepMats_i, Rt);
	detRep := det(id_(Rt^n) - t*g);
	(hStarNum, hStarDenom) := hStarList_i;
	if not zero((hStarNum * detRep) % hStarDenom) then (
	    print "bad symmetry:";
	    print g;
	    error("equivariant hStar not polynomial");
	    );
	(hStarNum * detRep) // hStarDenom
	); -- list of Ehrhart H* polynomials note that denominator is det(I - tg)
    H := (matrix {ehrhartHStarList} * (inverse T) * transpose matrix {gens R})_(0,0);
    result := {H};
    if opts.ReturnTable then result = result | {T};
    if opts.ReturnPartitionList then result = result | {toList \ partitions n};
    if opts.ReturnHStarList then result = result | {ehrhartHStarList};
    result
    )


-- obit polytope under Sn
-- expects a single column matrix: a point in QQ^n
orbitPolytope = method()
orbitPolytope Matrix := p -> (
    n := numRows p;
    if numColumns p != 1 then error("expected matrix with 1 column");
    V := map(QQ^n, QQ^0, 0);
    for g in symmetricGroup n do (
	V = V | g*p;
	);
    convexHull V
    )


end

load "equivariantEhrhart.m2"

P = convexHull transpose matrix "1,1,0,0;1,0,1,0;1,0,0,1;0,1,1,0;0,1,0,1;0,0,1,1"
M2134 = matrix "0,1,0,0;1,0,0,0;0,0,1,0;0,0,0,1"
M2341 = matrix "0,1,0,0;0,0,1,0;0,0,0,1;1,0,0,0"
M3214 = matrix "0,0,1,0;0,1,0,0;1,0,0,0;0,0,0,1"

isSymmetric(P, M2134)
isSymmetric(P, M2341)
isSymmetric(P, {M2134, M2341})

L = {M2134, M2341, id_(ZZ^4)}
G = group(L, Verbose => true)

L' = {M2341, M3214}
G' = group(L', Verbose => true)

#G
#G'

netList conjugacyClasses(G, Verbose => true, ListRepsOnly => true)
netList conjugacyClasses(G', Verbose => true, ListRepsOnly => true)

M23451 = permutationMatrix {1,2,3,4,0}
M21345 = permutationMatrix {1,0,2,3,4}
S5 = elapsedTime group({M23451, M21345});

M234561 = permutationMatrix {1,2,3,4,5,0}
M213456 = permutationMatrix {1,0,2,3,4,5}
S6 = elapsedTime group({M234561, M213456}, Verbose => true);
-- took around 300 seconds (Verbose mode)

T6 = symmetricGroup(6);

D12 = group({
	permutationMatrix {1,2,3,4,5,0},
	permutationMatrix {0,5,4,3,2,1}},
    Verbose => true)

conjugacyClasses(T6, ListRepsOnly => true)


P = hypersimplex(6, 2)
S5 = symmetricGroup(5);
C = conjugacyClasses(S5, ListRepsOnly => true)

netList elapsedTime equivariantEhrhartSeries hypersimplex(6, 3)
equivariantEhrhartSeries permutohedron 3


P = orbitPolytope transpose matrix "0,0,0,1,2"
vertices P
netList equivariantEhrhartSeries P


P = orbitPolytope transpose matrix "0,1,3"
vertices P
netList equivariantEhrhartSeries P

--------------------
A = QQ[x]
B = frac A[t]
1/(B_0)
--------------------
